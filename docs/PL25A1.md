# PL-25A1 USB Host-to-Host Bridge Controller

## Overview

The Prolific PL-25A1 is a single chip Hi-Speed USB Host-to-Host bridge controller designed for direct PC-to-PC connections via USB.

- **Vendor ID**: 0x067B (Prolific Technology, Inc.)
- **Product ID**: 0x25A1
- **USB Version**: USB 2.0 Hi-Speed (480 Mbps)
- **Primary Use**: Windows Easy Transfer cable, host-to-host networking

## Endpoint Configuration

The PL-25A1 implements a standard USB configuration with multiple endpoints for different types of data transfer:

### 1. Control Endpoint (EP0)
Standard USB control endpoint used for device configuration and vendor-specific commands.

```rust
use rusb::{Context, Device, DeviceHandle};

const VID_PROLIFIC: u16 = 0x067b;
const PID_PL25A1: u16 = 0x25a1;

struct PL25A1Device {
    handle: DeviceHandle<Context>,
}

impl PL25A1Device {
    pub fn new() -> Result<Self, rusb::Error> {
        let context = Context::new()?;
        let devices = context.devices()?;
        
        for device in devices.iter() {
            let desc = device.device_descriptor()?;
            if desc.vendor_id() == VID_PROLIFIC && desc.product_id() == PID_PL25A1 {
                let handle = device.open()?;
                return Ok(PL25A1Device { handle });
            }
        }
        
        Err(rusb::Error::NoDevice)
    }
}
```

### 2. Bulk IN/OUT Endpoints

Used for actual data transfer between hosts. These endpoints handle the primary communication payload.

```rust
impl PL25A1Device {
    // Typical bulk endpoint addresses for PL-25A1
    const BULK_OUT_EP: u8 = 0x02;  // Host -> Device
    const BULK_IN_EP: u8 = 0x81;   // Device -> Host
    
    pub fn bulk_write(&self, data: &[u8], timeout: Duration) -> Result<usize, rusb::Error> {
        self.handle.write_bulk(Self::BULK_OUT_EP, data, timeout)
    }
    
    pub fn bulk_read(&self, buffer: &mut [u8], timeout: Duration) -> Result<usize, rusb::Error> {
        self.handle.read_bulk(Self::BULK_IN_EP, buffer, timeout)
    }
    
    // Example: Send data packet
    pub fn send_packet(&self, packet: &[u8]) -> Result<(), Box<dyn std::error::Error>> {
        let bytes_written = self.bulk_write(packet, Duration::from_secs(5))?;
        if bytes_written != packet.len() {
            return Err("Incomplete write".into());
        }
        Ok(())
    }
    
    // Example: Receive data packet
    pub fn receive_packet(&self, max_size: usize) -> Result<Vec<u8>, Box<dyn std::error::Error>> {
        let mut buffer = vec![0u8; max_size];
        let bytes_read = self.bulk_read(&mut buffer, Duration::from_secs(5))?;
        buffer.truncate(bytes_read);
        Ok(buffer)
    }
}
```

### 3. Interrupt IN Endpoint

Used for connection status monitoring and asynchronous event notifications. This endpoint is crucial for detecting connection state changes between the two hosts.

```rust
use std::time::Duration;

impl PL25A1Device {
    const INTERRUPT_IN_EP: u8 = 0x83;  // Typical interrupt endpoint
    const INTERRUPT_BUFFER_SIZE: usize = 64;
    
    // Poll interrupt endpoint for status updates
    pub fn poll_interrupt(&self) -> Result<Vec<u8>, rusb::Error> {
        let mut buffer = vec![0u8; Self::INTERRUPT_BUFFER_SIZE];
        let timeout = Duration::from_millis(100);
        
        match self.handle.read_interrupt(Self::INTERRUPT_IN_EP, &mut buffer, timeout) {
            Ok(bytes_read) => {
                buffer.truncate(bytes_read);
                Ok(buffer)
            }
            Err(rusb::Error::Timeout) => Ok(Vec::new()), // No data available
            Err(e) => Err(e),
        }
    }
    
    // Monitor connection status changes
    pub fn monitor_connection(&self) -> Result<(), Box<dyn std::error::Error>> {
        loop {
            match self.poll_interrupt() {
                Ok(data) if !data.is_empty() => {
                    println!("Interrupt data received: {:02x?}", data);
                    // Process interrupt data here
                }
                Ok(_) => {
                    // No interrupt data, continue polling
                    std::thread::sleep(Duration::from_millis(50));
                }
                Err(e) => {
                    eprintln!("Interrupt polling error: {}", e);
                    break;
                }
            }
        }
        Ok(())
    }
}
```

## Control Transfer Vendor Commands

The PL-25A1 supports several vendor-specific control requests through endpoint 0:

### Vendor IN Commands (Device -> Host)

```rust
impl PL25A1Device {
    // 0xF7: Query device/feature status (related to 0xF8)
    pub fn query_feature_status(&self) -> Result<[u8; 2], rusb::Error> {
        let mut buffer = [0u8; 2];
        let request_type = rusb::request_type(
            rusb::Direction::In,
            rusb::RequestType::Vendor,
            rusb::Recipient::Device,
        );
        
        self.handle.read_control(
            request_type,
            0xF7,          // bRequest
            0,             // wValue
            0,             // wIndex
            &mut buffer,
            Duration::from_secs(1),
        )?;
        
        Ok(buffer)
    }
    
    // 0xFB: Get connection state (local/remote status)
    pub fn get_connection_state(&self) -> Result<ConnectionState, Box<dyn std::error::Error>> {
        let mut buffer = [0u8; 2];
        let request_type = rusb::request_type(
            rusb::Direction::In,
            rusb::RequestType::Vendor,
            rusb::Recipient::Device,
        );
        
        self.handle.read_control(
            request_type,
            0xFB,
            0,
            0,
            &mut buffer,
            Duration::from_secs(1),
        )?;
        
        Ok(ConnectionState::from_bytes(buffer))
    }
}

#[derive(Debug, Clone, Copy)]
pub struct ConnectionState {
    pub local_state: u8,
    pub remote_state: u8,
}

impl ConnectionState {
    pub fn from_bytes(bytes: [u8; 2]) -> Self {
        Self {
            local_state: bytes[0],
            remote_state: bytes[1],
        }
    }
    
    pub fn is_disconnected(&self) -> bool {
        (self.local_state & 0x02) != 0 || (self.remote_state & 0x02) != 0
    }
    
    pub fn is_ready(&self) -> bool {
        (self.local_state & 0x04) != 0 && (self.remote_state & 0x04) != 0
    }
    
    pub fn get_connector_id(&self) -> (bool, bool) {
        let local_connector = (self.local_state & 0x08) != 0;
        let remote_connector = (self.remote_state & 0x08) != 0;
        (local_connector, remote_connector)
    }
}
```

### Vendor OUT Commands (Host -> Device)

```rust
impl PL25A1Device {
    // 0xF8: Set device/feature configuration (related to 0xF7)
    pub async fn set_feature_config(&self, config: [u8; 2]) -> Result<(), rusb::Error> {
        let handle = &self.handle;
        let config = config.clone();
        task::spawn_blocking(move || {
            let request_type = rusb::request_type(
                rusb::Direction::Out,
                rusb::RequestType::Vendor,
                rusb::Recipient::Device,
            );
            
            handle.write_control(
                request_type,
                0xF8,
                0,
                0,
                &config,
                Duration::from_secs(1),
            )?;
            
            Ok(())
        }).await.unwrap()
    }
    
    // 0xF9: Power off device
    pub async fn power_off(&self) -> Result<(), rusb::Error> {
        let handle = &self.handle;
        task::spawn_blocking(move || {
            let request_type = rusb::request_type(
                rusb::Direction::Out,
                rusb::RequestType::Vendor,
                rusb::Recipient::Device,
            );
            
            handle.write_control(
                request_type,
                0xF9,
                0,
                0,
                &[],
                Duration::from_secs(1),
            )?;
            
            Ok(())
        }).await.unwrap()
    }
    
    // 0xFA: Reset device
    pub async fn reset_device(&self) -> Result<(), rusb::Error> {
        let handle = &self.handle;
        task::spawn_blocking(move || {
            let request_type = rusb::request_type(
                rusb::Direction::Out,
                rusb::RequestType::Vendor,
                rusb::Recipient::Device,
            );
            
            handle.write_control(
                request_type,
                0xFA,
                0,
                0,
                &[],
                Duration::from_secs(1),
            )?;
            
            Ok(())
        }).await.unwrap()
    }
}
```

## Data Bitfield Specifications

### Connection State Response (0xFB Vendor IN)

연결 상태는 2바이트로 구성되며, 각각 local과 remote 상태를 나타냅니다:

| Bit | Value | Name | Description |
|-----|-------|------|-------------|
| 0 | 0x01 | RESERVED_0 | 예약된 비트 (미사용) |
| 1 | 0x02 | DISCONNECTED | 물리적 연결 해제 상태 |
| 2 | 0x04 | READY | 장치 열거 완료 및 준비 상태 |
| 3 | 0x08 | CONNECTOR_ID | 케이블 커넥터 식별 비트 (고정값, 케이블 위치에 따라 결정) |
| 4-7 | 0x10-0x80 | RESERVED | 예약된 비트들 |

#### 상태 조합 해석

- **정상 연결**: READY 비트 설정, DISCONNECTED 비트 해제
- **연결 해제**: DISCONNECTED 비트 설정
- **초기화 중**: READY 비트 해제 상태
- **커넥터 구분**: CONNECTOR_ID는 케이블의 물리적 위치에 따른 고정값으로 A/B 측 구분

#### 일반적인 상태 값 (예시)

**참고**: CONNECTOR_ID 비트는 케이블의 물리적 위치에 따른 고정값이므로 실제 값은 하드웨어에 따라 다를 수 있습니다.

| 상태 | Local | Remote | 설명 |
|-----|-------|--------|------|
| 초기 상태 | 0x08 | 0x00 | 로컬 커넥터 ID 고정, 리모트 아직 연결 안됨 |
| 부분 연결 | 0x0C | 0x02 | 로컬 준비 완료, 리모트는 연결 해제 |
| 정상 연결 | 0x0C | 0x04 | 로컬 Connector A (0x08) + 준비, 리모트 Connector B + 준비 |
| 연결 오류 | 0x0A | 0x02 | 로컬 Connector A + 연결 해제, 리모트 연결 해제 |

### Feature Status Data (0xF7/0xF8 Vendor Commands)

기능 상태는 2바이트로 구성되며, 다양한 장치 기능을 제어합니다:

#### 첫 번째 바이트 (하위 8비트)

| Bit | Value | Name | Description |
|-----|-------|------|-------------|
| 0 | 0x01 | FEATURE_0 | 기능 0 (용도 불명) |
| 1 | 0x02 | FEATURE_1 | 기능 1 (용도 불명) |
| 2 | 0x04 | FEATURE_2 | 기능 2 (용도 불명) |
| 3 | 0x08 | FEATURE_3 | 기능 3 (용도 불명) |
| 4 | 0x10 | FEATURE_4 | 기능 4 (용도 불명) |
| 5 | 0x20 | FEATURE_5 | 기능 5 (용도 불명) |
| 6 | 0x40 | FEATURE_6 | 기능 6 (용도 불명) |
| 7 | 0x80 | FEATURE_7 | 기능 7 (용도 불명) |

#### 두 번째 바이트 (상위 8비트)

노트에서 관찰된 [0x06, 0x80] 패턴을 바탕으로:

| Bit Position | Value | Name | Description |
|-------------|-------|------|-------------|
| 8-10 | 0x06 | STATUS_FLAGS | 상태 표시 플래그 (0x06 = 비트 1,2 설정) |
| 11-14 | 0x00 | RESERVED | 예약된 비트들 |
| 15 | 0x80 | ENABLE_FLAG | 전체 기능 활성화 플래그 |

#### 관찰된 패턴 분석

- **[0x06, 0x80]**: 특정 상태 또는 기능을 나타내는 조합
  - 0x06 = 0b00000110 (비트 1,2 설정)
  - 0x80 = 0b10000000 (최상위 비트 설정)
- 이 패턴은 0xF8 명령과 연관되어 설정 가능한 것으로 추정

### Interrupt Endpoint Data Format

Interrupt IN 엔드포인트에서 수신되는 데이터 구조:

#### 예상 데이터 구조 (추정)

| Offset | Size | Field | Description |
|--------|------|-------|-------------|
| 0 | 1 | Event Type | 이벤트 타입 (연결 변경, 오류 등) |
| 1 | 1 | Local State | 로컬 연결 상태 (0xFB와 동일 형식) |
| 2 | 1 | Remote State | 리모트 연결 상태 (0xFB와 동일 형식) |
| 3 | 1 | Reserved | 예약 또는 추가 상태 정보 |
| 4-N | Variable | Additional Data | 이벤트별 추가 데이터 |

#### 이벤트 타입 (추정)

| Value | Event Type | Description |
|-------|------------|-------------|
| 0x01 | CONNECTION_CHANGE | 연결 상태 변경 |
| 0x02 | FEATURE_CHANGE | 기능 상태 변경 |
| 0x03 | ERROR_EVENT | 오류 발생 |
| 0xFF | UNKNOWN | 알 수 없는 이벤트 |

### Control Transfer Request Format

#### Vendor IN Request (0xF7, 0xFB)

```
bmRequestType: 0xC0 (Device-to-Host, Vendor, Device)
bRequest: 0xF7 또는 0xFB
wValue: 0x0000
wIndex: 0x0000
wLength: 2 (2바이트 응답)
```

#### Vendor OUT Request (0xF8, 0xF9, 0xFA)

```
bmRequestType: 0x40 (Host-to-Device, Vendor, Device)
bRequest: 0xF8, 0xF9, 또는 0xFA
wValue: 0x0000
wIndex: 0x0000
wLength: 0 (0xF9, 0xFA) 또는 2 (0xF8)
Data: [] (0xF9, 0xFA) 또는 [2바이트 설정값] (0xF8)
```

## Complete Usage Example

```rust
use std::time::Duration;
use std::sync::Arc;
use tokio::{time, task};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Initialize device
    let device = Arc::new(PL25A1Device::new().await?);
    
    // Check initial connection state
    let state = device.get_connection_state().await?;
    println!("Initial state: {}", decode_connection_state(state.local_state, state.remote_state));
    
    // Start interrupt monitoring in background
    let device_clone = Arc::clone(&device);
    task::spawn(async move {
        if let Err(e) = device_clone.monitor_connection().await {
            eprintln!("Connection monitoring failed: {}", e);
        }
    });
    
    // Main communication loop
    loop {
        // Check if both sides are ready
        let state = device.get_connection_state().await?;
        if state.is_ready() && !state.is_disconnected() {
            // Send some data
            let data = b"Hello from host";
            device.send_packet(data).await?;
            
            // Receive response
            match device.receive_packet(1024).await {
                Ok(response) => {
                    println!("Received: {:?}", String::from_utf8_lossy(&response));
                }
                Err(e) => {
                    eprintln!("Receive error: {}", e);
                }
            }
        }
        
        time::sleep(Duration::from_millis(100)).await;
    }
}
```

## Linux Support

The PL-25A1 is supported in Linux through the `plusb` driver (CONFIG_USB_NET_PLUSB). When properly configured, it creates a `usbX` network interface for host-to-host networking.

## Notes

- The interrupt endpoint typically remains idle until specific events occur
- Vendor commands 0xF7/0xF8 appear to be paired for feature query/configuration
- Connection state monitoring through 0xFB is crucial for reliable communication
- The CONNECTOR_ID bit helps identify which end of the cable is being used

## References

- USB 2.0 Specification
- Prolific Technology PL-25A1 datasheet
- Linux USB Network driver documentation