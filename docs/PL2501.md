PL2501 USB Host to Host 브리지 칩에서 지원하는 컨트롤 커맨드들을 조사해보겠습니다.PL2501 USB Host to Host 브리지 칩에서 지원하는 컨트롤 커맨드들을 분석한 결과를 정리해드리겠습니다.

## Vendor-Specific Control Commands

PL2501은 Linux driver에서 다음과 같은 vendor-specific control request를 지원합니다:

### Basic Vendor Request Structure
```c
static inline int
pl2501_vendor_req(struct usbnet *dev, u8 req, u8 val, u8 index)
{
    return usb_control_msg(dev->udev,
        usb_rcvctrlpipe(dev->udev, 0),
        req,
        USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
        val, index,
        NULL, 0,
        USB_CTRL_GET_TIMEOUT);
}
```

### QuickLink Feature Control Commands

#### 1. Clear QuickLink Features (bRequest = 1)
```c
static inline int
pl2501_clear_QuickLink_features(struct usbnet *dev, int val)
{
    return pl2501_vendor_req(dev, 1, (u8) val, 0);
}
```

#### 2. Set QuickLink Features (bRequest = 3)
```c
static inline int
pl2501_set_QuickLink_features(struct usbnet *dev, int val)
{
    return pl2501_vendor_req(dev, 3, (u8) val, 0);
}
```

## Feature Control Bit Definitions

PL2501에서 사용되는 feature bit들은 다음과 같습니다:

```c
#define PL2501_S_EN        (1<<7)    /* (feature only) suspend enable */
#define PL2501_TX_READY    (1<<5)    /* (interrupt only) transmit ready */
#define PL2501_RESET_OUT   (1<<4)    /* reset output pipe */
#define PL2501_RESET_IN    (1<<3)    /* reset input pipe */
#define PL2501_TX_C        (1<<2)    /* transmission complete */
#define PL2501_TX_REQ      (1<<1)    /* transmission received */
#define PL2501_PEER_E      (1<<0)    /* peer exists */
```

## 지원되는 Control Commands 목록

### 1. Device Reset Command
```c
// Reset sequence used during device initialization
int pl2501_reset(struct usbnet *dev)
{
    int status;
    status = pl2501_set_QuickLink_features(dev,
        PL2501_S_EN|PL2501_RESET_OUT|PL2501_RESET_IN|PL2501_PEER_E);
    return status;
}
```

### 2. Feature Management Commands

#### Suspend Enable/Disable
```c
// Enable suspend mode
pl2501_set_QuickLink_features(dev, PL2501_S_EN);

// Disable suspend mode  
pl2501_clear_QuickLink_features(dev, PL2501_S_EN);
```

#### Pipe Reset Commands
```c
// Reset output pipe
pl2501_set_QuickLink_features(dev, PL2501_RESET_OUT);

// Reset input pipe
pl2501_set_QuickLink_features(dev, PL2501_RESET_IN);

// Reset both pipes
pl2501_set_QuickLink_features(dev, PL2501_RESET_OUT | PL2501_RESET_IN);
```

#### Peer Detection
```c
// Enable peer detection
pl2501_set_QuickLink_features(dev, PL2501_PEER_E);

// Check if peer exists (read-only status)
// This bit is set automatically when remote device is connected
```

#### Transmission Control
```c
// Check transmission complete status
pl2501_set_QuickLink_features(dev, PL2501_TX_C);

// Check transmission request status  
pl2501_set_QuickLink_features(dev, PL2501_TX_REQ);

// Check transmit ready status (interrupt only)
pl2501_set_QuickLink_features(dev, PL2501_TX_READY);
```

## Complete Control Command Implementation

### Full Feature Control Function
```c
typedef enum {
    PL2501_CMD_CLEAR_FEATURES = 1,
    PL2501_CMD_SET_FEATURES = 3,
    // Other vendor commands may exist but are undocumented
} pl2501_vendor_cmd_t;

typedef enum {
    PL2501_FEATURE_SUSPEND_EN    = (1<<7),
    PL2501_FEATURE_TX_READY      = (1<<5),
    PL2501_FEATURE_RESET_OUT     = (1<<4),
    PL2501_FEATURE_RESET_IN      = (1<<3),
    PL2501_FEATURE_TX_COMPLETE   = (1<<2),
    PL2501_FEATURE_TX_REQUEST    = (1<<1),
    PL2501_FEATURE_PEER_EXISTS   = (1<<0)
} pl2501_feature_t;

// Generic vendor request function
int pl2501_vendor_request(libusb_device_handle *handle, 
                         uint8_t bRequest, 
                         uint16_t wValue, 
                         uint16_t wIndex)
{
    return libusb_control_transfer(handle,
        LIBUSB_ENDPOINT_IN | LIBUSB_REQUEST_TYPE_VENDOR | LIBUSB_RECIPIENT_DEVICE,
        bRequest,
        wValue,
        wIndex,
        NULL, 0,
        5000); // 5 second timeout
}

// Set multiple features at once
int pl2501_set_features(libusb_device_handle *handle, uint8_t features)
{
    return pl2501_vendor_request(handle, PL2501_CMD_SET_FEATURES, features, 0);
}

// Clear multiple features at once
int pl2501_clear_features(libusb_device_handle *handle, uint8_t features)
{
    return pl2501_vendor_request(handle, PL2501_CMD_CLEAR_FEATURES, features, 0);
}

// High-level control functions
int pl2501_enable_suspend(libusb_device_handle *handle)
{
    return pl2501_set_features(handle, PL2501_FEATURE_SUSPEND_EN);
}

int pl2501_reset_pipes(libusb_device_handle *handle)
{
    return pl2501_set_features(handle, 
        PL2501_FEATURE_RESET_OUT | PL2501_FEATURE_RESET_IN);
}

int pl2501_enable_peer_detection(libusb_device_handle *handle)
{
    return pl2501_set_features(handle, PL2501_FEATURE_PEER_EXISTS);
}

int pl2501_full_reset(libusb_device_handle *handle)
{
    // Complete reset sequence as used in Linux driver
    return pl2501_set_features(handle,
        PL2501_FEATURE_SUSPEND_EN | 
        PL2501_FEATURE_RESET_OUT | 
        PL2501_FEATURE_RESET_IN | 
        PL2501_FEATURE_PEER_EXISTS);
}
```

## Status Reading Commands

```c
// Read current feature status (if supported)
int pl2501_read_status(libusb_device_handle *handle, uint8_t *status)
{
    return libusb_control_transfer(handle,
        LIBUSB_ENDPOINT_IN | LIBUSB_REQUEST_TYPE_VENDOR | LIBUSB_RECIPIENT_DEVICE,
        0x02, // Hypothetical status read command
        0x00,
        0x00,
        status, 1,
        1000);
}

// Check specific feature status
bool pl2501_is_peer_connected(libusb_device_handle *handle)
{
    uint8_t status;
    if (pl2501_read_status(handle, &status) >= 0) {
        return (status & PL2501_FEATURE_PEER_EXISTS) != 0;
    }
    return false;
}
```

## Standard USB Control Commands

PL2501은 또한 표준 USB control request들도 지원합니다:

- **GET_DESCRIPTOR**: Device, Configuration, String descriptors
- **SET_CONFIGURATION**: Configuration 설정
- **GET_STATUS**: Device/Interface/Endpoint 상태
- **SET_FEATURE/CLEAR_FEATURE**: Standard USB features
- **SET_ADDRESS**: USB 주소 설정

PL2501은 PL2301/PL2302와 동일한 프로토콜을 사용하므로, 기존 plusb 드라이버의 명령어들을 그대로 사용할 수 있습니다.

이러한 control command들을 통해 PL2501의 다양한 기능을 제어하고 상태를 모니터링할 수 있습니다.